<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>SequoiaDB: sdbclient::sdbCollection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SequoiaDB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesdbclient.html">sdbclient</a></li><li class="navelem"><a class="el" href="classsdbclient_1_1sdbCollection.html">sdbCollection</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classsdbclient_1_1sdbCollection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sdbclient::sdbCollection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Database operation interfaces of collection.  
 <a href="classsdbclient_1_1sdbCollection.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="client_8hpp_source.html">client.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a736a05798f38ea0ed987fd0171684add"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a736a05798f38ea0ed987fd0171684add"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a736a05798f38ea0ed987fd0171684add">sdbCollection</a> ()</td></tr>
<tr class="memdesc:a736a05798f38ea0ed987fd0171684add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a736a05798f38ea0ed987fd0171684add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b5b02f01eb513bfd86ec71705ed90d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46b5b02f01eb513bfd86ec71705ed90d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a46b5b02f01eb513bfd86ec71705ed90d">~sdbCollection</a> ()</td></tr>
<tr class="memdesc:a46b5b02f01eb513bfd86ec71705ed90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a46b5b02f01eb513bfd86ec71705ed90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a4d640622d115cf726626f15e5329b"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ac2a4d640622d115cf726626f15e5329b">getCount</a> (SINT64 &amp;count, const bson::BSONObj &amp;condition=_sdbStaticObject)</td></tr>
<tr class="memdesc:ac2a4d640622d115cf726626f15e5329b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the count of matching documents in current collection.  <a href="#ac2a4d640622d115cf726626f15e5329b"></a><br/></td></tr>
<tr class="separator:ac2a4d640622d115cf726626f15e5329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6088162e2083805eb52cd2410e925203"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a6088162e2083805eb52cd2410e925203">split</a> (const CHAR *pSourceGroupName, const CHAR *pTargetGroupName, const bson::BSONObj &amp;splitCondition, const bson::BSONObj &amp;splitEndCondition=_sdbStaticObject)</td></tr>
<tr class="memdesc:a6088162e2083805eb52cd2410e925203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the specified collection from source replica group to target replica group by range.  <a href="#a6088162e2083805eb52cd2410e925203"></a><br/></td></tr>
<tr class="separator:a6088162e2083805eb52cd2410e925203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8919c63570b4b3df679375db896339ec"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a8919c63570b4b3df679375db896339ec">split</a> (const CHAR *pSourceGroupName, const CHAR *pTargetGroupName, FLOAT64 percent)</td></tr>
<tr class="memdesc:a8919c63570b4b3df679375db896339ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the specified collection from source replica group to target replica group by percent.  <a href="#a8919c63570b4b3df679375db896339ec"></a><br/></td></tr>
<tr class="separator:a8919c63570b4b3df679375db896339ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a10f9333670535e166a34a308ff5d6e"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a7a10f9333670535e166a34a308ff5d6e">splitAsync</a> (SINT64 &amp;taskID, const CHAR *pSourceGroupName, const CHAR *pTargetGroupName, const bson::BSONObj &amp;splitCondition, const bson::BSONObj &amp;splitEndCondition=_sdbStaticObject)</td></tr>
<tr class="memdesc:a7a10f9333670535e166a34a308ff5d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the specified collection from source replica group to target replica group by range.  <a href="#a7a10f9333670535e166a34a308ff5d6e"></a><br/></td></tr>
<tr class="separator:a7a10f9333670535e166a34a308ff5d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4fa8fa068f241d997d3c21b388c323"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#add4fa8fa068f241d997d3c21b388c323">splitAsync</a> (const CHAR *pSourceGroupName, const CHAR *pTargetGroupName, FLOAT64 percent, SINT64 &amp;taskID)</td></tr>
<tr class="memdesc:add4fa8fa068f241d997d3c21b388c323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the specified collection from source replica group to target replica group by percent.  <a href="#add4fa8fa068f241d997d3c21b388c323"></a><br/></td></tr>
<tr class="separator:add4fa8fa068f241d997d3c21b388c323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e7129e2f3eae91ac9a0e2ce2d379d3"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a69e7129e2f3eae91ac9a0e2ce2d379d3">alterCollection</a> (const bson::BSONObj &amp;options)</td></tr>
<tr class="memdesc:a69e7129e2f3eae91ac9a0e2ce2d379d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alter the current collection.  <a href="#a69e7129e2f3eae91ac9a0e2ce2d379d3"></a><br/></td></tr>
<tr class="separator:a69e7129e2f3eae91ac9a0e2ce2d379d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf15277babcda91553ba20e6bea3c06"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#adcf15277babcda91553ba20e6bea3c06">bulkInsert</a> (SINT32 flags, std::vector&lt; bson::BSONObj &gt; &amp;obj)</td></tr>
<tr class="memdesc:adcf15277babcda91553ba20e6bea3c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a bulk of bson objects into current collection.  <a href="#adcf15277babcda91553ba20e6bea3c06"></a><br/></td></tr>
<tr class="separator:adcf15277babcda91553ba20e6bea3c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1f71eb57d42dd766ef43d90702f837"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a4f1f71eb57d42dd766ef43d90702f837">insert</a> (const bson::BSONObj &amp;obj, bson::OID *id=NULL)</td></tr>
<tr class="memdesc:a4f1f71eb57d42dd766ef43d90702f837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a bson object into current collection.  <a href="#a4f1f71eb57d42dd766ef43d90702f837"></a><br/></td></tr>
<tr class="separator:a4f1f71eb57d42dd766ef43d90702f837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0d3636bfd79c2c9d7f61e101cb0fcb"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a4a0d3636bfd79c2c9d7f61e101cb0fcb">update</a> (const bson::BSONObj &amp;rule, const bson::BSONObj &amp;condition=_sdbStaticObject, const bson::BSONObj &amp;hint=_sdbStaticObject)</td></tr>
<tr class="memdesc:a4a0d3636bfd79c2c9d7f61e101cb0fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the matching documents in current collection.  <a href="#a4a0d3636bfd79c2c9d7f61e101cb0fcb"></a><br/></td></tr>
<tr class="separator:a4a0d3636bfd79c2c9d7f61e101cb0fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50ed90fd2420790deff1a2f36254ede"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ab50ed90fd2420790deff1a2f36254ede">upsert</a> (const bson::BSONObj &amp;rule, const bson::BSONObj &amp;condition=_sdbStaticObject, const bson::BSONObj &amp;hint=_sdbStaticObject)</td></tr>
<tr class="memdesc:ab50ed90fd2420790deff1a2f36254ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the matching documents in current collection, insert if no matching.  <a href="#ab50ed90fd2420790deff1a2f36254ede"></a><br/></td></tr>
<tr class="separator:ab50ed90fd2420790deff1a2f36254ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282d616532a50056a8583e1725bea04c"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a282d616532a50056a8583e1725bea04c">del</a> (const bson::BSONObj &amp;condition=_sdbStaticObject, const bson::BSONObj &amp;hint=_sdbStaticObject)</td></tr>
<tr class="memdesc:a282d616532a50056a8583e1725bea04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the matching documents in current collection.  <a href="#a282d616532a50056a8583e1725bea04c"></a><br/></td></tr>
<tr class="separator:a282d616532a50056a8583e1725bea04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51587e70ae435db5b94af8cbb930908f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51587e70ae435db5b94af8cbb930908f"></a>
INT32&#160;</td><td class="memItemRight" valign="bottom"><b>query</b> (<a class="el" href="classsdbclient_1_1__sdbCursor.html">_sdbCursor</a> **cursor, const bson::BSONObj &amp;condition=_sdbStaticObject, const bson::BSONObj &amp;selected=_sdbStaticObject, const bson::BSONObj &amp;orderBy=_sdbStaticObject, const bson::BSONObj &amp;hint=_sdbStaticObject, INT64 numToSkip=0, INT64 numToReturn=-1, INT32 flag=0)</td></tr>
<tr class="separator:a51587e70ae435db5b94af8cbb930908f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5dae5cc3d1db97a86c6910be9ef259"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a5b5dae5cc3d1db97a86c6910be9ef259">query</a> (<a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;cursor, const bson::BSONObj &amp;condition=_sdbStaticObject, const bson::BSONObj &amp;selected=_sdbStaticObject, const bson::BSONObj &amp;orderBy=_sdbStaticObject, const bson::BSONObj &amp;hint=_sdbStaticObject, INT64 numToSkip=0, INT64 numToReturn=-1, INT32 flag=0)</td></tr>
<tr class="memdesc:a5b5dae5cc3d1db97a86c6910be9ef259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matching documents in current collection.  <a href="#a5b5dae5cc3d1db97a86c6910be9ef259"></a><br/></td></tr>
<tr class="separator:a5b5dae5cc3d1db97a86c6910be9ef259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233a9df73d247e5a78bd113fe2bd2dff"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a233a9df73d247e5a78bd113fe2bd2dff">createIndex</a> (const bson::BSONObj &amp;indexDef, const CHAR *pName, BOOLEAN isUnique, BOOLEAN isEnforced)</td></tr>
<tr class="memdesc:a233a9df73d247e5a78bd113fe2bd2dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the index in current collection.  <a href="#a233a9df73d247e5a78bd113fe2bd2dff"></a><br/></td></tr>
<tr class="separator:a233a9df73d247e5a78bd113fe2bd2dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f87e58a837453b5c1403b99e4769ce6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f87e58a837453b5c1403b99e4769ce6"></a>
INT32&#160;</td><td class="memItemRight" valign="bottom"><b>getIndexes</b> (<a class="el" href="classsdbclient_1_1__sdbCursor.html">_sdbCursor</a> **cursor, const CHAR *pName)</td></tr>
<tr class="separator:a3f87e58a837453b5c1403b99e4769ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2164c2e7f259d93859f31b49dedc1"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#adad2164c2e7f259d93859f31b49dedc1">getIndexes</a> (<a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;cursor, const CHAR *pName)</td></tr>
<tr class="memdesc:adad2164c2e7f259d93859f31b49dedc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of or one of the indexes in current collection.  <a href="#adad2164c2e7f259d93859f31b49dedc1"></a><br/></td></tr>
<tr class="separator:adad2164c2e7f259d93859f31b49dedc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae960e209c8ffeb60e95712591b88e021"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ae960e209c8ffeb60e95712591b88e021">dropIndex</a> (const CHAR *pName)</td></tr>
<tr class="memdesc:ae960e209c8ffeb60e95712591b88e021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the index in current collection.  <a href="#ae960e209c8ffeb60e95712591b88e021"></a><br/></td></tr>
<tr class="separator:ae960e209c8ffeb60e95712591b88e021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4162e8c438202e2d096a2a813b513a"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#aff4162e8c438202e2d096a2a813b513a">create</a> ()</td></tr>
<tr class="memdesc:aff4162e8c438202e2d096a2a813b513a"><td class="mdescLeft">&#160;</td><td class="mdescRight">create the specified collection of current collection space  <a href="#aff4162e8c438202e2d096a2a813b513a"></a><br/></td></tr>
<tr class="separator:aff4162e8c438202e2d096a2a813b513a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c326fdf010bcf82b15646432bfdfd98"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a0c326fdf010bcf82b15646432bfdfd98">drop</a> ()</td></tr>
<tr class="memdesc:a0c326fdf010bcf82b15646432bfdfd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop the specified collection of current collection space.  <a href="#a0c326fdf010bcf82b15646432bfdfd98"></a><br/></td></tr>
<tr class="separator:a0c326fdf010bcf82b15646432bfdfd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de62c9d26baa45e3c82d00a4528218f"><td class="memItemLeft" align="right" valign="top">const CHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a9de62c9d26baa45e3c82d00a4528218f">getCollectionName</a> ()</td></tr>
<tr class="memdesc:a9de62c9d26baa45e3c82d00a4528218f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of specified collection in current collection space.  <a href="#a9de62c9d26baa45e3c82d00a4528218f"></a><br/></td></tr>
<tr class="separator:a9de62c9d26baa45e3c82d00a4528218f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8f0ce34cbacba60fcf4012d0987bc9"><td class="memItemLeft" align="right" valign="top">const CHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a1b8f0ce34cbacba60fcf4012d0987bc9">getCSName</a> ()</td></tr>
<tr class="memdesc:a1b8f0ce34cbacba60fcf4012d0987bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of current collection space.  <a href="#a1b8f0ce34cbacba60fcf4012d0987bc9"></a><br/></td></tr>
<tr class="separator:a1b8f0ce34cbacba60fcf4012d0987bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbae19cc6beac4a3cd0fe4f4993214"><td class="memItemLeft" align="right" valign="top">const CHAR *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a0ccbae19cc6beac4a3cd0fe4f4993214">getFullName</a> ()</td></tr>
<tr class="memdesc:a0ccbae19cc6beac4a3cd0fe4f4993214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the full name of specified collection in current collection space.  <a href="#a0ccbae19cc6beac4a3cd0fe4f4993214"></a><br/></td></tr>
<tr class="separator:a0ccbae19cc6beac4a3cd0fe4f4993214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01cd7a4eca35d9923dfe10530454e94a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01cd7a4eca35d9923dfe10530454e94a"></a>
INT32&#160;</td><td class="memItemRight" valign="bottom"><b>aggregate</b> (<a class="el" href="classsdbclient_1_1__sdbCursor.html">_sdbCursor</a> **cursor, std::vector&lt; bson::BSONObj &gt; &amp;obj)</td></tr>
<tr class="separator:a01cd7a4eca35d9923dfe10530454e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a1f054c19946c883564c260b58eeb0"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a18a1f054c19946c883564c260b58eeb0">aggregate</a> (<a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;cursor, std::vector&lt; bson::BSONObj &gt; &amp;obj)</td></tr>
<tr class="memdesc:a18a1f054c19946c883564c260b58eeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute aggregate operation in specified collection.  <a href="#a18a1f054c19946c883564c260b58eeb0"></a><br/></td></tr>
<tr class="separator:a18a1f054c19946c883564c260b58eeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f310775913ce7610aec91a12347e00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68f310775913ce7610aec91a12347e00"></a>
INT32&#160;</td><td class="memItemRight" valign="bottom"><b>getQueryMeta</b> (<a class="el" href="classsdbclient_1_1__sdbCursor.html">_sdbCursor</a> **cursor, const bson::BSONObj &amp;condition, const bson::BSONObj &amp;orderBy, const bson::BSONObj &amp;hint, INT64 numToSkip, INT64 numToReturn)</td></tr>
<tr class="separator:a68f310775913ce7610aec91a12347e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81f17ef5bbe4447ffa1edde10c13ccf"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ad81f17ef5bbe4447ffa1edde10c13ccf">getQueryMeta</a> (<a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;cursor, const bson::BSONObj &amp;condition, const bson::BSONObj &amp;orderBy, const bson::BSONObj &amp;hint, INT64 numToSkip, INT64 numToReturn)</td></tr>
<tr class="memdesc:ad81f17ef5bbe4447ffa1edde10c13ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index blocks' or data blocks' infomations for concurrent query.  <a href="#ad81f17ef5bbe4447ffa1edde10c13ccf"></a><br/></td></tr>
<tr class="separator:ad81f17ef5bbe4447ffa1edde10c13ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055fd1f3bc94c2349cf4685fa3e6c7e2"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a055fd1f3bc94c2349cf4685fa3e6c7e2">attachCollection</a> (const CHAR *subClFullName, const bson::BSONObj &amp;options)</td></tr>
<tr class="memdesc:a055fd1f3bc94c2349cf4685fa3e6c7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach the specified collection.  <a href="#a055fd1f3bc94c2349cf4685fa3e6c7e2"></a><br/></td></tr>
<tr class="separator:a055fd1f3bc94c2349cf4685fa3e6c7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae109b9915c1f22d57a448ee22f3dbdde"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ae109b9915c1f22d57a448ee22f3dbdde">detachCollection</a> (const CHAR *subClFullName)</td></tr>
<tr class="memdesc:ae109b9915c1f22d57a448ee22f3dbdde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dettach the specified collection.  <a href="#ae109b9915c1f22d57a448ee22f3dbdde"></a><br/></td></tr>
<tr class="separator:ae109b9915c1f22d57a448ee22f3dbdde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaa3f848a87ed2db340ea04a5fb6b55"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#afdaa3f848a87ed2db340ea04a5fb6b55">explain</a> (<a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;cursor, const bson::BSONObj &amp;condition=_sdbStaticObject, const bson::BSONObj &amp;select=_sdbStaticObject, const bson::BSONObj &amp;orderBy=_sdbStaticObject, const bson::BSONObj &amp;hint=_sdbStaticObject, INT64 numToSkip=0, INT64 numToReturn=-1, INT32 flag=0, const bson::BSONObj &amp;options=_sdbStaticObject)</td></tr>
<tr class="memdesc:afdaa3f848a87ed2db340ea04a5fb6b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access plan of query.  <a href="#afdaa3f848a87ed2db340ea04a5fb6b55"></a><br/></td></tr>
<tr class="separator:afdaa3f848a87ed2db340ea04a5fb6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b462cd1506e4afd0cc56d7f4a806d5"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ab1b462cd1506e4afd0cc56d7f4a806d5">createLob</a> (<a class="el" href="classsdbclient_1_1sdbLob.html">sdbLob</a> &amp;lob, const bson::OID *oid=NULL)</td></tr>
<tr class="memdesc:ab1b462cd1506e4afd0cc56d7f4a806d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create large object.  <a href="#ab1b462cd1506e4afd0cc56d7f4a806d5"></a><br/></td></tr>
<tr class="separator:ab1b462cd1506e4afd0cc56d7f4a806d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608760487730d302da5a1e7dc4ce386e"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a608760487730d302da5a1e7dc4ce386e">removeLob</a> (const bson::OID &amp;oid)</td></tr>
<tr class="memdesc:a608760487730d302da5a1e7dc4ce386e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove large object.  <a href="#a608760487730d302da5a1e7dc4ce386e"></a><br/></td></tr>
<tr class="separator:a608760487730d302da5a1e7dc4ce386e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a6611ea6816d1c7da7974fe8b892b0"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#af7a6611ea6816d1c7da7974fe8b892b0">openLob</a> (<a class="el" href="classsdbclient_1_1sdbLob.html">sdbLob</a> &amp;lob, const bson::OID &amp;oid)</td></tr>
<tr class="memdesc:af7a6611ea6816d1c7da7974fe8b892b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an existing large object for reading.  <a href="#af7a6611ea6816d1c7da7974fe8b892b0"></a><br/></td></tr>
<tr class="separator:af7a6611ea6816d1c7da7974fe8b892b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9256ad1c6815a3941e4f7d2178588eb"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#ad9256ad1c6815a3941e4f7d2178588eb">listLobs</a> (<a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;cursor)</td></tr>
<tr class="memdesc:ad9256ad1c6815a3941e4f7d2178588eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all the lobs' meta data in current collection.  <a href="#ad9256ad1c6815a3941e4f7d2178588eb"></a><br/></td></tr>
<tr class="separator:ad9256ad1c6815a3941e4f7d2178588eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7da5c47b4d2dccf4750a83ca5eaa1fbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsdbclient_1_1__sdbCollection.html">_sdbCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdbclient_1_1sdbCollection.html#a7da5c47b4d2dccf4750a83ca5eaa1fbe">pCollection</a></td></tr>
<tr class="separator:a7da5c47b4d2dccf4750a83ca5eaa1fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Database operation interfaces of collection. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a18a1f054c19946c883564c260b58eeb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::aggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bson::BSONObj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute aggregate operation in specified collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The array of bson objects </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor object of result </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69e7129e2f3eae91ac9a0e2ce2d379d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::alterCollection </td>
          <td>(</td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alter the current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The modified options as following: ReplSize Number of replnodes for sync write </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a055fd1f3bc94c2349cf4685fa3e6c7e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::attachCollection </td>
          <td>(</td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>subClFullName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attach the specified collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subClFullName</td><td>The name of the subcollection </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>The low boudary and up boudary eg: {"LowBound":{a:1},"UpBound":{a:100}} </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcf15277babcda91553ba20e6bea3c06"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::bulkInsert </td>
          <td>(</td>
          <td class="paramtype">SINT32&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bson::BSONObj &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a bulk of bson objects into current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>FLG_INSERT_CONTONDUP or 0. While FLG_INSERT_CONTONDUP is set, if some records hit index key duplicate error, database will skip them and go on inserting. However, while 0 is set, database will stop inserting in that case, and return errno code. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The array of inserted bson objects </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff4162e8c438202e2d096a2a813b513a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create the specified collection of current collection space </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>This function will be deprecated in SequoiaDB1.6, use sdbCollectionSpace::createCollection instead of it. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a233a9df73d247e5a78bd113fe2bd2dff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::createIndex </td>
          <td>(</td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>indexDef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>isUnique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOLEAN&#160;</td>
          <td class="paramname"><em>isEnforced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the index in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">indexDef</td><td>The bson structure of index element, e.g. {name:1, age:-1} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pIndexName</td><td>The index name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isUnique</td><td>Whether the index elements are unique or not </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isEnforced</td><td>Whether the index is enforced unique This element is meaningful when isUnique is set to true </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1b462cd1506e4afd0cc56d7f4a806d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::createLob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbLob.html">sdbLob</a> &amp;&#160;</td>
          <td class="paramname"><em>lob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::OID *&#160;</td>
          <td class="paramname"><em>oid</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create large object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oid</td><td>The id of the large object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lob</td><td>The newly create large object </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>When oid is offered, use it to create a lob for writing, otherwise, API will generate one. After creating a lob, need to close it to release resource. </dd></dl>

</div>
</div>
<a class="anchor" id="a282d616532a50056a8583e1725bea04c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::del </td>
          <td>(</td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the matching documents in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, delete all the documents if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>The hint, automatically match the optimal hint if not provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae109b9915c1f22d57a448ee22f3dbdde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::detachCollection </td>
          <td>(</td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>subClFullName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dettach the specified collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subClFullName</td><td>The name of the subcollection </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c326fdf010bcf82b15646432bfdfd98"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::drop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the specified collection of current collection space. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>This function will be deprecated in SequoiaDB1.6, use <a class="el" href="classsdbclient_1_1sdbCollectionSpace.html#aee316a74e8688e7b93fda1f5b9d5b325" title="Drop the specified collection in current collection space.">sdbCollectionSpace::dropCollection</a> instead of it. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae960e209c8ffeb60e95712591b88e021"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::dropIndex </td>
          <td>(</td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop the index in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pName</td><td>The index name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdaa3f848a87ed2db340ea04a5fb6b55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::explain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>select</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>orderBy</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT64&#160;</td>
          <td class="paramname"><em>numToSkip</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT64&#160;</td>
          <td class="paramname"><em>numToReturn</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get access plan of query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, return all the documents if null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>The selective rule, return the whole document if null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderBy</td><td>The ordered rule, never sort if null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>The hint, automatically match the optimal hint if null </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numToSkip</td><td>Skip the first numToSkip documents, never skip if this parameter is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numToReturn</td><td>Only return numToReturn documents, return all if this parameter is -1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>the rules of explain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The flags of query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor of current query </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9de62c9d26baa45e3c82d00a4528218f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CHAR * sdbclient::sdbCollection::getCollectionName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of specified collection in current collection space. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of specified collection. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2a4d640622d115cf726626f15e5329b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::getCount </td>
          <td>(</td>
          <td class="paramtype">SINT64 &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the count of matching documents in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, return the count of all documents if this parameter is empty </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>The count of matching documents, matches all records if not provided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b8f0ce34cbacba60fcf4012d0987bc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CHAR * sdbclient::sdbCollection::getCSName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of current collection space. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of current collection space. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ccbae19cc6beac4a3cd0fe4f4993214"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CHAR * sdbclient::sdbCollection::getFullName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the full name of specified collection in current collection space. </p>
<dl class="section return"><dt>Returns</dt><dd>The full name of specified collection. </dd></dl>

</div>
</div>
<a class="anchor" id="adad2164c2e7f259d93859f31b49dedc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::getIndexes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all of or one of the indexes in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pName</td><td>The index name, returns all of the indexes if this parameter is null </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor of all the result for current query </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad81f17ef5bbe4447ffa1edde10c13ccf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::getQueryMeta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>orderBy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT64&#160;</td>
          <td class="paramname"><em>numToSkip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT64&#160;</td>
          <td class="paramname"><em>numToReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index blocks' or data blocks' infomations for concurrent query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, return the whole range of index blocks if not provided eg:{"age":{"$gt":25},"age":{"$lt":75}} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderBy</td><td>The ordered rule, result set is unordered if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>One of the indexs in current collection, using default index to query if not provided eg:{"":"ageIndex"} </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numToSkip</td><td>Skip the first numToSkip documents, default is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numToReturn</td><td>Only return numToReturn documents, default is -1 for returning all results </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The result of query </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f1f71eb57d42dd766ef43d90702f837"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::insert </td>
          <td>(</td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bson::OID *&#160;</td>
          <td class="paramname"><em>id</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a bson object into current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">obj</td><td>The inserted bson object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>The object id of inserted bson object in current collection, the memory of id will be invalidated when next insert/bulkInsert is performed or the obj is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9256ad1c6815a3941e4f7d2178588eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::listLobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all the lobs' meta data in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The curosr reference of the result </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7a6611ea6816d1c7da7974fe8b892b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::openLob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbLob.html">sdbLob</a> &amp;&#160;</td>
          <td class="paramname"><em>lob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::OID &amp;&#160;</td>
          <td class="paramname"><em>oid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open an existing large object for reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oid</td><td>The id of the large object </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lob</td><td>The large object to get </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Need to close lob to release resource, after opening a lob. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b5dae5cc3d1db97a86c6910be9ef259"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsdbclient_1_1sdbCursor.html">sdbCursor</a> &amp;&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>selected</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>orderBy</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT64&#160;</td>
          <td class="paramname"><em>numToSkip</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT64&#160;</td>
          <td class="paramname"><em>numToReturn</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>flag</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the matching documents in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, return all the documents if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">selected</td><td>The selective rule, return the whole document if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orderBy</td><td>The ordered rule, result set is unordered if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>The hint, automatically match the optimal hint if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numToSkip</td><td>Skip the first numToSkip documents, default is 0 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numToReturn</td><td>Only return numToReturn documents, default is -1 for returning all results </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag</td><td>The query flag, defalt to be 0 <pre class="fragment">FLG_QUERY_FORCE_HINT(0x00000080)      : Force to use specified hint to query, if database have no index assigned by the hint, fail to query
FLG_QUERY_PARALLED(0x00000100)        : Enable paralled sub query
FLG_QUERY_WITH_RETURNDATA(0x00000200) : In general, query won't return data until cursor get from database,
                                        when add this flag, return data in query response, it will be more high-performance
</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor of current query </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a608760487730d302da5a1e7dc4ce386e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::removeLob </td>
          <td>(</td>
          <td class="paramtype">const bson::OID &amp;&#160;</td>
          <td class="paramname"><em>oid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove large object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oid</td><td>The id of the large object </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6088162e2083805eb52cd2410e925203"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::split </td>
          <td>(</td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pSourceGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pTargetGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>splitCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>splitEndCondition</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the specified collection from source replica group to target replica group by range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSourceGroupName</td><td>The source replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTargetGroupName</td><td>The target replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitCondition</td><td>The split condition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitEndCondition</td><td>The split end condition or null eg:If we create a collection with the option {ShardingKey:{"age":1},ShardingType:"Hash",Partition:2^10}, we can fill {age:30} as the splitCondition, and fill {age:60} as the splitEndCondition. when split, the target replica group will get the records whose age's hash value are in [30,60). If splitEndCondition is null, they are in [30,max). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8919c63570b4b3df679375db896339ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::split </td>
          <td>(</td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pSourceGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pTargetGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLOAT64&#160;</td>
          <td class="paramname"><em>percent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the specified collection from source replica group to target replica group by percent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSourceGroupName</td><td>The source replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTargetGroupName</td><td>The target replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">percent</td><td>The split percent, Range:(0,100] </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a10f9333670535e166a34a308ff5d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::splitAsync </td>
          <td>(</td>
          <td class="paramtype">SINT64 &amp;&#160;</td>
          <td class="paramname"><em>taskID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pSourceGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pTargetGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>splitCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>splitEndCondition</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the specified collection from source replica group to target replica group by range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">taskID</td><td>The id of current split task </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pSourceGroupName</td><td>The source replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTargetGroupName</td><td>The target replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitCondition</td><td>The split condition </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splitEndCondition</td><td>The split end condition or null eg:If we create a collection with the option {ShardingKey:{"age":1},ShardingType:"Hash",Partition:2^10}, we can fill {age:30} as the splitCondition, and fill {age:60} as the splitEndCondition. when split, the target replica group will get the records whose age's hash value are in [30,60). If splitEndCondition is null, they are in [30,max). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add4fa8fa068f241d997d3c21b388c323"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 INT32 sdbclient::sdbCollection::splitAsync </td>
          <td>(</td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pSourceGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHAR *&#160;</td>
          <td class="paramname"><em>pTargetGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FLOAT64&#160;</td>
          <td class="paramname"><em>percent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SINT64 &amp;&#160;</td>
          <td class="paramname"><em>taskID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the specified collection from source replica group to target replica group by percent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pSourceGroupName</td><td>The source replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pTargetGroupName</td><td>The target replica group name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">percent</td><td>The split percent, Range:(0.0, 100.0] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">taskID</td><td>The id of current split task </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a0d3636bfd79c2c9d7f61e101cb0fcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::update </td>
          <td>(</td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the matching documents in current collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>The updating rule </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, update all the documents if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>The hint, automatically match the optimal hint if not provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It won't work to update the "ShardingKey" field, but the other fields take effect </dd></dl>

</div>
</div>
<a class="anchor" id="ab50ed90fd2420790deff1a2f36254ede"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">INT32 sdbclient::sdbCollection::upsert </td>
          <td>(</td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>rule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>condition</em> = <code>_sdbStaticObject</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bson::BSONObj &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>_sdbStaticObject</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the matching documents in current collection, insert if no matching. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rule</td><td>The updating rule </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">condition</td><td>The matching rule, update all the documents if not provided </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hint</td><td>The hint, automatically match the optimal hint if not provided </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">SDB_OK</td><td>Operation Success </td></tr>
    <tr><td class="paramname">Others</td><td>Operation Fail </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It won't work to upsert the "ShardingKey" field, but the other fields take effect </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7da5c47b4d2dccf4750a83ca5eaa1fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sdbclient::sdbCollection::pCollection</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pointer of virtual base class <a class="el" href="classsdbclient_1_1__sdbCollection.html">_sdbCollection</a></p>
<p>Class <a class="el" href="classsdbclient_1_1sdbCollection.html" title="Database operation interfaces of collection.">sdbCollection</a> is a shell for <a class="el" href="classsdbclient_1_1__sdbCollection.html">_sdbCollection</a>. We use pCollection to call the methods in class <a class="el" href="classsdbclient_1_1__sdbCollection.html">_sdbCollection</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/sequoiadb/client/include/<a class="el" href="client_8hpp_source.html">client.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Oct 31 2014 11:44:50 for SequoiaDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
