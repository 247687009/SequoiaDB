<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_5y2_lvm_5n">
  <title>db.collectionspace.collection.upsert()</title>
  <body>
    <section>
      <title>NAME</title>
      <p>upsert - Update collection records.</p>
    </section>
    <section>
      <title>SYNOPSIS</title>
      <p></p><apiname>db.collectionspace.collection.upsert</apiname>(<parmname>&lt;rule></parmname>,<parmname>[cond]</parmname>,<parmname>[hint]</parmname>)
    </section>
    <section>
      <title>CATEGORY</title>
      <p></p>Collection
    </section>
    <section>
      <title>DESCRIPTION</title> 
      <p>Update collection records. The methods upsert() and update() are both used to update
        records. But when no records is matched according to the parameter "cond", "update" does nothing, but "upset" will insert
        data once.</p>
      <parml>
        <plentry>
          <pt>rule (json object)</pt>
          <pd>Update rule. Records will be updated according to the value of "rule".</pd>
        </plentry>
        <plentry>
          <pt>cond (json object)</pt>
          <pd>Selecting contiditon. When it is null, update all the records. If it is not null,
            update records that match the condition in "cond".</pd>
        </plentry>
        <plentry>
          <pt>hint (json object)</pt>
          <pd>Specify access plan.
            <parml>
              <plentry>
                <pt>Format</pt>
                <pd>The definition of upsert() must contain field "rule" which should be a json object. "cond" and "hint" are optional fields. "hint" is a json object that include one field, the field name will be ignored, and its value specifies the index name, when the value of the field is null, all the records in the collection will be accessed, its format is {"":null} or {"":"&lt;indexname>"}.</pd>                
                <pd>{&lt; {&lt;{""update operator 1"":{field name 1:"value"},"update operator 2":{"field name 2":"value 2"},...}>,[{"field name 1":{"match operator 1":"value 1"},"field name 2":{"match operator 2":"value 2"},...}],[{"":"index name"|null}]}</pd>
              </plentry>
            </parml></pd>
        </plentry>        
      </parml>
      <note>
        <p>
          <ul>
            <li>upsert() does not support the update of sharding key in this version, if there are update operations on sharding key, these operations will be automatically neglected and the update of other fields will still work without any problems.</li>
          </ul>
        </p>
      </note>
    </section>    
    <section>
      <title>Examples</title>
      <p>Supposing that there are 2 records in the collection "bar".</p>
      <codeblock>{
    "_id": {
      "$oid": "516a76a1c9565daf06030000"
    },
    "age": 10,
    "name": "Tom"
  }
  {
    "_id": {
      "$oid": "516a76a1c9565daf06050000"
    },
    "a": 10,
    "age": 21
    }</codeblock>
      <p>Update all the records according to the update rule. That's to say, we merely set the
        value of "rule", but not "cond" or "hint".</p>
      <p>
        <codeblock>db.foo.bar.upsert({$inc:{age:1},$set:{name:"Mike"}})</codeblock>
      </p>
      <p>This operation is equivalent to that of the method "update()". It updates all the
        records in the collection "bar". It adds 1 to the value of  "age" and changes the value
        of "name" into "Mike". If a record doesn't contain the field "name", "$set" will insert the field of "name"
        and its value into the record and return with the method "find".</p>
      <codeblock> {
    "_id": {
      "$oid": "516a76a1c9565daf06030000"
    },
    "age": 11,
    "name": "Mike"
  }
  {
    "_id": {
      "$oid": "516a76a1c9565daf06050000"
    },
    "a": 10,
    "age": 22,
    "name":"Mike"
    }</codeblock>
      <p>Select records match the selecting condition, and update them according to the update rule. That's to say, we set the value
        of "rule" and "cond".</p>
      <p>
        <codeblock>db.foo.bar.upsert({$inc:{age:3}},{type:{$exists:1}})</codeblock>
      </p>
      <p>This operation will update records that contains the field "type" in the collection
        "bar" and add 3 to the value of their "age" field. The 2 records above don't contain the
        field "type", so it will insert a new record. This new record contains only the field
        "_id" and the field "age". The value of "_id" is automatically generated by the system.
        The value of "age" is 3.
        <codeblock>{
    "_id": {
      "$oid": "516a76a1c9565daf06030000"
    },
    "age": 11,
    "name": "Mike"
  }
  {
    "_id": {
      "$oid": "516a76a1c9565daf06050000"
    },
    "a": 10,
    "age": 22,
    "name":"Mike"
  } 
{
  "_id": {
    "$oid": "516cfc334630a7f338c169b0"
  },
  "age": 3
  }</codeblock></p>
      <p>Update records according to Access plan, supposing that the index name "testIndex"
        exists in the collection.</p>
      <codeblock>db.foo.bar.upsert({$inc:{age:1}},{age:{$gt:20}},{"":"testIndex"})></codeblock>
      <p>This operation is equivalent to update(), it accesses records that contain a value which is no less than 20 in the field "age" according to the index named "testIndex", and add 1 to the value of the field "age". Then it returns:
        <codeblock> {
    "_id": {
      "$oid": "516a76a1c9565daf06050000"
    },
    "a": 10,
    "age": 23,
    "name":"Mike"
  } </codeblock></p>
    </section>
  </body>
  <related-links>
    <link href="cl.update.dita" format="dita" type="topic"></link>
  </related-links>
</topic>
